/*
 *  File Name:   PBKDF2.cs
 *
 *  Project:     SocketServer
 *
 *  Copyright (c) 2021 Bradley Willcott
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * ****************************************************************
 * Name: Bradley Willcott
 * ID:   M198449
 * Date: 31/10/2021
 * ****************************************************************
 */

namespace SocketServer
{
    using System;
    using System.Security.Cryptography;

    using Microsoft.AspNetCore.Cryptography.KeyDerivation;

    using static System.Convert;

    /// <summary>
    /// Defines the <see cref="Pbkdf2"/>.
    /// </summary>
    public static class Pbkdf2
    {
        /// <summary>
        /// Defines the HASH_ALGORITHM.
        /// </summary>
        private const string HASH_ALGORITHM = "sha512";

        /// <summary>
        /// Defines the HASH_ALGORITHM_INDEX.
        /// </summary>
        private const int HASH_ALGORITHM_INDEX = 0;

        /// <summary>
        /// Defines the HASH_BYTE_SIZE.
        /// </summary>
        private const int HASH_BYTE_SIZE = 128;

        /// <summary>
        /// Defines the HASH_SECTIONS.
        /// </summary>
        private const int HASH_SECTIONS = 5;

        /// <summary>
        /// Defines the HASH_SIZE_INDEX.
        /// </summary>
        private const int HASH_SIZE_INDEX = 2;

        /// <summary>
        /// Defines the ITERATION_INDEX.
        /// </summary>
        private const int ITERATION_INDEX = 1;

        /// <summary>
        /// Used by the main() method in for loop test.
        /// </summary>
        private const int NUM_OF_TEST_CYCLES = 10;

        /// <summary>
        /// Defines the PBKDF2_INDEX.
        /// </summary>
        private const int PBKDF2_INDEX = 4;

        /// <summary>
        /// Defines the PBKDF2_ITERATIONS.
        /// </summary>
        private const int PBKDF2_ITERATIONS = 200000;

        /// <summary>
        /// Defines the SALT_BYTE_SIZE.
        /// </summary>
        private const int SALT_BYTE_SIZE = HASH_BYTE_SIZE;

        /// <summary>
        /// Defines the SALT_INDEX.
        /// </summary>
        private const int SALT_INDEX = 3;

        /// <summary>
        /// The cryptographic random number generator.
        /// </summary>
        /// <autogeneratedoc/>
        private static readonly RNGCryptoServiceProvider RNGCSP = new RNGCryptoServiceProvider();

        /// <summary>
        /// The CreateHash.
        /// </summary>
        /// <param name="password">The password <see cref="string"/>.</param>
        /// <returns>The hashed <see cref="string"/>.</returns>
        public static string CreateHash(string password)
        {
            // Generate a random salt
            byte[] salt = new byte[SALT_BYTE_SIZE];
            RNGCSP.GetBytes(salt);

            // Hash the password
            var prf = KeyDerivationPrf.HMACSHA512;
            byte[] hash = KeyDerivation.Pbkdf2(password, salt, prf, PBKDF2_ITERATIONS, HASH_BYTE_SIZE);

            int hashSize = hash.Length;

            // format: algorithm:iterations:hashSize:salt:hash
            return HASH_ALGORITHM
                    + ":"
                    + PBKDF2_ITERATIONS
                    + ":" + hashSize
                    + ":"
                    + ToBase64String(salt)
                    + ":"
                    + ToBase64String(hash);
        }

        /// <summary>
        /// Verifies the password.
        /// </summary>
        /// <param name="password">   The password.</param>
        /// <param name="correctHash">The correct hash.</param>
        /// <returns></returns>
        /// <exception cref="SocketServer.Pbkdf2.InvalidHashException">
        /// Fields are missing from the password hash. or Could not parse the iteration count as an
        /// integer. or Invalid number of iterations. Must be &gt;= 1. or Base64 decoding of salt
        /// failed. or Base64 decoding of pbkdf2 output failed. or Could not parse the hash size as
        /// an integer. or Hash length doesn't match stored hash length.
        /// </exception>
        /// <exception cref="SocketServer.Pbkdf2.CannotPerformOperationException">
        /// Unsupported hash type.
        /// </exception>
        /// <autogeneratedoc/>
        public static bool VerifyPassword(string password, string correctHash)

        {
            // Split the hash into its parts
            string[] parts = correctHash.Split(":");

            // Do we have enough parts?
            if (parts.Length != HASH_SECTIONS)
            {
                throw new InvalidHashException(

                    @"Fields are missing from the password hash."
            );
            }

            // Is the stored algorithm a supported one?
            if (!parts[HASH_ALGORITHM_INDEX].Equals(HASH_ALGORITHM))
            {
                throw new CannotPerformOperationException(
                        @"Unsupported hash type."
                );
            }

            int iterations = 0;

            // Get the stored number for the quantity of iterations used by the hashing algorithm.
            try
            {
                iterations = int.Parse(parts[ITERATION_INDEX]);
            }
            catch (FormatException ex)
            {
                throw new InvalidHashException(
                        $"Could not parse the iteration count as an integer.\n{ex}"
                );
            }

            // Check it.
            if (iterations < 1)
            {
                throw new InvalidHashException(
                        @"Invalid number of iterations. Must be >= 1."
                );
            }

            byte[] salt = null;

            // Get the stored 'salt' array.
            try
            {
                salt = FromBase64String(parts[SALT_INDEX]);
            }
            catch (FormatException ex)
            {
                throw new InvalidHashException(
                        $"Base64 decoding of salt failed.\n{ex}"
                );
            }

            byte[] hash = null;
            // Get the stored password hash string.
            try
            {
                hash = FromBase64String(parts[PBKDF2_INDEX]);
            }
            catch (FormatException ex)
            {
                throw new InvalidHashException(
                        $"Base64 decoding of pbkdf2 output failed.\v{ex}"
                );
            }

            int storedHashSize = 0;

            // Get the stored number for the length of the original hash.
            try
            {
                storedHashSize = int.Parse(parts[HASH_SIZE_INDEX]);
            }
            catch (FormatException ex)
            {
                throw new InvalidHashException(
                        $"Could not parse the hash size as an integer.\n{ex}"
                );
            }

            // Check that we have the correct hash length.
            if (storedHashSize != hash.Length)
            {
                throw new InvalidHashException(
                        @"Hash length doesn't match stored hash length."
                );
            }

            // Compute the hash of the provided password, using the same salt, iteration count, and
            // hash length
            var prf = KeyDerivationPrf.HMACSHA512;
            byte[] testHash = KeyDerivation.Pbkdf2(password, salt, prf, iterations, hash.Length);

            // Compare the hashes in constant time. The password is correct if both hashes match.
            return SlowEquals(hash, testHash);
        }

        /// <summary>
        /// Compares two byte arrays in length-constant time. <br/> This comparison method is used
        /// so that password hashes cannot be extracted from an on-line system using a timing attack
        /// and then attacked off-line.
        /// </summary>
        /// <param name="a">the first byte array</param>
        /// <param name="b">the second byte array</param>
        /// <returns><c>true</c> if both byte arrays are the same, <c>false</c> if not.</returns>
        /// <autogeneratedoc/>
        private static bool SlowEquals(byte[] a, byte[] b)
        {
            int diff = a.Length ^ b.Length;

            for (int i = 0; i < a.Length && i < b.Length; i++)
            {
                diff |= a[i] ^ b[i];
            }

            return diff == 0;
        }

        /// <summary>
        /// This exception is thrown when something is wrong with the platform your code is running
        /// on, and for some reason it's not safe to verify a password on it.
        /// </summary>
        /// <seealso cref="System.Exception"/>
        /// <autogeneratedoc/>
        public class CannotPerformOperationException : Exception

        {
            public CannotPerformOperationException(string? message) : base(message)

            {
            }

            public CannotPerformOperationException(string? message, Exception? source) : base(message, source)
            {
            }
        }

        /// <summary>
        /// The <c>correctHash</c> parameter you gave to the <see cref="VerifyPassword(string,
        /// string)"/> method was somehow corrupted. Note that some ways of corrupting a hash are
        /// impossible to detect, and their only symptom will be that <see
        /// cref="VerifyPassword(string, string)"/> will return <c>false</c> even though the correct
        /// password was given. So <see cref="InvalidHashException"/> is not guaranteed to be thrown
        /// if a hash has been changed, but if it is thrown, then you can be sure that the hash
        /// <i>was</i> changed.
        /// </summary>
        /// <seealso cref="System.Exception"/>
        /// <autogeneratedoc/>
        public class InvalidHashException : Exception

        {
            public InvalidHashException(string? message) : base(message)

            {
            }

            public InvalidHashException(string? message, Exception? source) : base(message, source)
            {
            }
        }
    }
}
